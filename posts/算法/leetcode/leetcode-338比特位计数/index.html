<!DOCTYPE html>
<html lang="zh-hans">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="LeetCode 338:比特位计数">
<meta itemprop="description" content="题目 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回
示例1:
 输入: 2 输出: [0, 1, 1]
 示例2:
 输入: 5 输出: [0, 1, 1, 2, 1, 2]
 进阶:
 给出时间复杂度为 O(n * sizeof(integer)) 的解答非常容易. 但你可以在线性时间 O(n) 内用一趟扫描做到吗? 要求算法的空间复杂度为 O(n) 你能进一步完善解法吗？要求在C&#43;&#43;或任何其他语言中不使用任何内置函数（如 C&#43;&#43; 中的 __builtin_popcount）来执行此操作  开始的思路 先不考虑进阶, 使用语言自带的函数进行解答，Golang中可以使用bits.OnesCount()函数来计算
func countBits(num int) []int { nums := make([]int, num&#43;1) for i := 0; i &lt;= num; i&#43;&#43; { nums[i] = bits."><meta itemprop="datePublished" content="2021-03-03T16:36:09&#43;08:00" />
<meta itemprop="dateModified" content="2021-03-03T16:36:09&#43;08:00" />
<meta itemprop="wordCount" content="548">
<meta itemprop="keywords" content="LeetCode," /><meta property="og:title" content="LeetCode 338:比特位计数" />
<meta property="og:description" content="题目 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回
示例1:
 输入: 2 输出: [0, 1, 1]
 示例2:
 输入: 5 输出: [0, 1, 1, 2, 1, 2]
 进阶:
 给出时间复杂度为 O(n * sizeof(integer)) 的解答非常容易. 但你可以在线性时间 O(n) 内用一趟扫描做到吗? 要求算法的空间复杂度为 O(n) 你能进一步完善解法吗？要求在C&#43;&#43;或任何其他语言中不使用任何内置函数（如 C&#43;&#43; 中的 __builtin_popcount）来执行此操作  开始的思路 先不考虑进阶, 使用语言自带的函数进行解答，Golang中可以使用bits.OnesCount()函数来计算
func countBits(num int) []int { nums := make([]int, num&#43;1) for i := 0; i &lt;= num; i&#43;&#43; { nums[i] = bits." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://roninzc.github.io/posts/%E7%AE%97%E6%B3%95/leetcode/leetcode-338%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-03T16:36:09&#43;08:00" />
<meta property="article:modified_time" content="2021-03-03T16:36:09&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 338:比特位计数"/>
<meta name="twitter:description" content="题目 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回
示例1:
 输入: 2 输出: [0, 1, 1]
 示例2:
 输入: 5 输出: [0, 1, 1, 2, 1, 2]
 进阶:
 给出时间复杂度为 O(n * sizeof(integer)) 的解答非常容易. 但你可以在线性时间 O(n) 内用一趟扫描做到吗? 要求算法的空间复杂度为 O(n) 你能进一步完善解法吗？要求在C&#43;&#43;或任何其他语言中不使用任何内置函数（如 C&#43;&#43; 中的 __builtin_popcount）来执行此操作  开始的思路 先不考虑进阶, 使用语言自带的函数进行解答，Golang中可以使用bits.OnesCount()函数来计算
func countBits(num int) []int { nums := make([]int, num&#43;1) for i := 0; i &lt;= num; i&#43;&#43; { nums[i] = bits."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>LeetCode 338:比特位计数</title>
	<link rel="stylesheet" href="https://roninzc.github.io/css/style.min.b21595ccbc2181c24e6a019eb9b89ca67727675a14634f9cbdb25e7a4f556601.css">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://roninzc.github.io">RoninZc</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="https://roninzc.github.io/tags/">标签</a>
					<a href="https://roninzc.github.io/about/">关于</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/RoninZc" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="菜单"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://roninzc.github.io/posts/">文章</a></li>
			<li><a href="https://roninzc.github.io/tags/">标签</a></li>
			<li><a href="https://roninzc.github.io/about/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>3-3, 2021</span></div>
				<h1>LeetCode 338:比特位计数</h1>
			</header>
			<div class="content">
				<h3 id="题目">题目<a href="#题目" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回</p>
<p>示例1:</p>
<blockquote>
<p>输入: 2
输出: [0, 1, 1]</p>
</blockquote>
<p>示例2:</p>
<blockquote>
<p>输入: 5
输出: [0, 1, 1, 2, 1, 2]</p>
</blockquote>
<p>进阶:</p>
<ul>
<li>给出时间复杂度为 O(n * sizeof(integer)) 的解答非常容易. 但你可以在线性时间 O(n) 内用一趟扫描做到吗?</li>
<li>要求算法的空间复杂度为 O(n)</li>
<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <strong>__builtin_popcount</strong>）来执行此操作</li>
</ul>
<h3 id="开始的思路">开始的思路<a href="#开始的思路" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>先不考虑进阶, 使用语言自带的函数进行解答，Golang中可以使用<code>bits.OnesCount()</code>函数来计算</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">countBits</span><span class="p">(</span><span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">num</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">bits</span><span class="p">.</span><span class="nf">OnesCount</span><span class="p">(</span><span class="nb">uint</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></div><p>这种解答十分简单，我们来尝试一下手写一个 OneCount()</p>
<p>leetcode 官方解答内提到有一个位运算的小技巧</p>
<blockquote>
<p>对于任意整数x, 令 x = x &amp; (x - 1) , 该运算将 x 的二进制表示的最后一个1变成0. 因此, 对x重复该操作, 直到x变成0, 则操作次数即为x的「一比特数」</p>
</blockquote>
<p>我们来实际操作一下试试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 8的二进制为 1000
</span><span class="c1">// 7的二进制为 0111
</span><span class="c1">// 我们进行 &amp; 操作
</span><span class="c1"></span><span class="mi">1000</span> <span class="o">&amp;</span> <span class="mo">0111</span> <span class="p">=</span> <span class="mo">0000</span> 
<span class="c1">// x 变成了 0 , 8的二进制数为1, 这符合我们的答案
</span><span class="c1">// 让我们再来一个
</span><span class="c1">// 6的二进制为 0110
</span><span class="c1">// 5的二进制为 0101
</span><span class="c1">// 4的二进制为 0100
</span><span class="c1">// 3的二进制为 0011
</span><span class="c1"></span><span class="mo">0111</span> <span class="o">&amp;</span> <span class="mo">0110</span> <span class="p">=</span> <span class="mo">0110</span> <span class="c1">// ones + 1
</span><span class="c1"></span><span class="mo">0110</span> <span class="o">&amp;</span> <span class="mo">0101</span> <span class="p">=</span> <span class="mo">0100</span> <span class="c1">// ones + 1
</span><span class="c1"></span><span class="mo">0101</span> <span class="o">&amp;</span> <span class="mo">0100</span> <span class="p">=</span> <span class="mo">0100</span> <span class="c1">// ones + 1
</span><span class="c1"></span><span class="mo">0100</span> <span class="o">&amp;</span> <span class="mo">0011</span> <span class="p">=</span> <span class="mo">0000</span> <span class="c1">// ones = 3 
</span><span class="c1">// 对此我只能发出咸鱼的声音，妙啊
</span></code></pre></div><p>对此技巧，我们可以写出:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">onesCount</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">ones</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">x</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&amp;=</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">ones</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>但是这依然不满足进阶解答的需求，所以我们继续</p>
<h3 id="进阶">进阶<a href="#进阶" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>要给出时间复杂度为 O(n) 的解法, 代表我们不能使用系统的内置函数, 且不能进入循环. 我们必须进行逻辑梳理</p>
<p>官方给出的解答: 动态规划&ndash;最高有效位 有些晦涩难懂</p>
<blockquote>
<p>需要对每个数遍历其二进制表示的每一位。可以换一个思路，当计算 i 的「一比特数」时，如果存在 0 ≤ j &lt; i，j 的「一比特数」已知，且 i 和 j 相比，i 的二进制表示只多了一个 1，则可以快速得到 i 的「一比特数」。</p>
<p>令 bits[i] 表示 i 的「一比特数」，则上述关系可以表示成：bits[i] = bits[j] + 1。</p>
<p>对于正整数 x，如果可以知道最大的正整数 y，使得 y ≤ x 且 y 是 2 的整数次幂，则 y 的二进制表示中只有最高位是 1，其余都是 0，此时称 y 为 x 的「最高有效位」。令 z = x − y，显然 0 ≤ z &lt; x，则 bits[x] = bits[z] + 1。</p>
<p>为了判断一个正整数是不是 2 的整数次幂，可以利用方法一中提到的按位与运算的性质。如果正整数 y 是 2 的整数次幂，则 y 的二进制表示中只有最高位是 1，其余都是 0，因此 y &amp; ( y − 1 ) = 0。由此可见，正整数 y 是 2 的整数次幂，当且仅当 y &amp; ( y − 1 ) = 0。</p>
<p>显然，0 的「一比特数」为 0。使用 highBit 表示当前的最高有效位，遍历从 1 到 num 的每个正整数 i，进行如下操作。</p>
<p>如果 i&amp;(i−1)=0，则令 highBit = i，更新当前的最高有效位。</p>
<p>i 比 i−highBit 的「一比特数」多 1，由于是从小到大遍历每个数，因此遍历到 i 时，i−highBit 的「一比特数」已知，令 bits[i] = bits[i−highBit] + 1。</p>
<p>最终得到的数组 bits 即为答案。</p>
<p>作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>我这尝试做出自己的解释：</p>
<ul>
<li>当一个数是 2 的整数次幂时, 它的二进制中1的数量只会是1</li>
<li>当一个数不是2的整数次幂时，它的二进制中1的数量为 <em><strong>(它 与 它上次为2的整数次幂的数的差值)的「一比特数」+ 1</strong></em></li>
</ul>
<p>我们可以来实际试试:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 8的二进制为 1000 它是2的整数次幂 所以它的二进制中1的数量只会是1
</span><span class="c1">// 那 9 呢？根据上面的总结 它的上次2的整数次幂的数为 8,9-8=1(0001) 的「一比特数」为1
</span><span class="c1">// 9 的二进制位是 1001 ,「一比特数」为 2, 完美
</span><span class="c1">// 那 10 呢？它的上次2的整数次幂的数依然为 8, 10-8=2(0010) 的「一比特数」为1
</span><span class="c1">// 10 的二进制位为 1010, 「一比特数」为 2
</span><span class="c1">// 继续 11 二进制为 1011, 11-8=3 , 3(0011)的「一比特数」为2 
</span><span class="c1">// 对此我只能发出咸鱼的声音，妙啊
</span><span class="c1"></span>
<span class="c1">// 所以我们能写出下面的方法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">countBits</span><span class="p">(</span><span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">bits</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">num</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">highBit</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">// 最高比特位 即 上次为2的整数次幂的数
</span><span class="c1"></span>  <span class="c1">// 0的「一比特数」为 0，不需要进入循环
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 这里是根据上面的位运算的技巧，判断是否为2的整数次幂，因为2的整数次幂只有一个1
</span><span class="c1"></span>  	<span class="k">if</span> <span class="nx">i</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">highBit</span> <span class="p">=</span> <span class="nx">i</span> <span class="c1">// 更新最高比特位
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="c1">// 它与它上次为2的整数次幂的数的差值 的「一比特数」+ 1
</span><span class="c1"></span>		<span class="nx">bits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">bits</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">highBit</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">bits</span>
<span class="p">}</span>
</code></pre></div><p>应该还是有些晦涩难懂，但是我也没得办法，这太抽象了，官方解答的其他动态规划思想就不继续了，我们还有新办法。</p>
<h3 id="新的办法">新的办法<a href="#新的办法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>对于所有的数字，只有两类 奇数|偶数:</p>
<ol>
<li>
<p>奇数: 在二进制中表示，奇数一定比前面的那个偶数多一个1，多的就是最低位的1</p>
<blockquote>
<p>举例：</p>
<p>0 = 0000    1 = 0001</p>
<p>2 = 0010    3 = 0011</p>
</blockquote>
<p>发现了没有，偶数的最低位总是0，奇数的最低位总是1，我们再考虑偶数</p>
</li>
<li>
<p>偶数: 二进制中，偶数中的1一定和除以2之后的那个数一样多，因为偶数的最低位总是0</p>
<p>除以2就只是右移一位，把最低位的0去掉而已，所以1的数量是不变的</p>
<blockquote>
<p>举例:</p>
<p>0 = 0000    1 = 0001 // 0不算, 1的「一比特数」= 0 + 1</p>
<p>2 = 0010    3 = 0011 // 2 / 2 = 1, 1的「一比特数」= 1 &hellip;</p>
<p>4 = 0100    5 = 0101</p>
<p>6 = 0110    7 = 0111</p>
</blockquote>
</li>
</ol>
<p>我们能根据上面的规律来写出以下代码</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">countBits</span><span class="p">(</span><span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">num</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="c1">// 判断是否为偶数，奇数的最后一位永远是1
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>以上思路来自:</p>
<p>作者：duadua
链接：https://leetcode-cn.com/problems/counting-bits/solution/hen-qing-xi-de-si-lu-by-duadua/
来源：力扣（LeetCode）</p>
</blockquote>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://roninzc.github.io/tags/leetcode">LeetCode</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>548 字</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2021-03-03 16:36 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://roninzc.github.io/posts/%E7%AE%97%E6%B3%95/leetcode/leetcode-354%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;新</span><br><span>LeetCode 354:俄罗斯信封套娃问题</span>
			</a>
			<a class="prev-post" href="https://roninzc.github.io/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/golang%E6%A0%87%E5%87%86%E5%BA%93%E9%99%90%E6%B5%81%E5%99%A8timerate%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">
				<span class="post-nav-label">旧&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Golang标准库限流器timerate使用介绍</span>
			</a>
		</div>
		<div id="comments" class="thin">
						<script src="https://utteranc.es/client.js"
							repo="RoninZc/blog"
							issue-term="pathname"
							theme="github-light"
							crossorigin="anonymous"
							async>
			</script>
		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2020 - 2021 <a href="https://roninzc.github.io">RoninZc</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a>
			
		</p>
	</footer>


	<script src="https://roninzc.github.io/js/main.min.3b8561d63aeee77aa04e677df95581a230b4b43adf7b208b8d671433e446cfc1.js"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-166045776-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>
